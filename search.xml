<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[docker-compose详解]]></title>
    <url>%2F2019%2F05%2F12%2Fdocker-compose%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[固定容器compose会查找之前的容器，把旧容器的volume-data拷贝到容器中。除非手动用docker rm命令删除容器，否则CONTAINER ID不会发生改变。 版本 Compose file format Docker Engine 1 1.9.0+ 2.0 1.10.0+ 2.1 1.12.0+ 2.2, 3.0, 3.1, 3.2 1.13.0+ 2.3, 3.3, 3.4, 3.5 17.06.0+ 2.4 17.12.0+ 3.6 18.02.0+ 3.7 18.06.0+ 文件结构说明根节点 version 定义了版本信息 services 定义了服务的配置信息 networks 定义了网络信息，提供给 services 中的 具体容器使用 volumes 定义了卷信息，提供给 services 中的 具体容器使用 services 的定义包含应用于为该服务启动的每个容器的配置，非常类似于将命令行的 docker container create networks 的定义类似于命令行的 docker network create volumes 的定义类似于命令行的 docker volume create 顶级配置container_name指定容器名称。Compose 的容器默认名称格式是：&lt;项目名称&gt;&lt;服务名称&gt;&lt;序号&gt; 注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称 labels为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息 123labels: com.startupteam.description: &quot;webapp for a startup team&quot; com.startupteam.department: &quot;devops department&quot; 构建时应用的配置选项 注意每个服务都必须通过 image 指令指定镜像或 build 指令（需要 Dockerfile）等来自动构建生成镜像 如果使用 build 指令，那么在 Dockerfile 中设置的选项(例如：CMD, EXPOSE, VOLUME, ENV 等) 将会自动被获取，无需在 docker-compose.yml 中再次设置 build指定 Dockerfile 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像。 类似于命令行的 docker build . 1234version: &apos;3&apos;services: webapp: build: . context指定 Dockerfile 所在文件夹的路径 dockerfile指定 Dockerfile 文件名 args类似Dockerfile 中的 ARG 指令，它可以在构建过程中指定环境变量，但是在构建成功后消失 context指定 Dockerfile 所在文件夹的路径 一个build配置的示例： 1234567891011121314version: &apos;3&apos;services: serviceXXX: build: context: ./config dockerfile: My_Dockerfile args: buildno: 1 password: secret #一般下面这种写法 - buildno=1 - password=secret #与env不同,arg允许空值 - buildno image指定为镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像 如果同时指定了 image和 build，, image 不在具有单独使用它的意义，而是指定了目前要构建的镜像的名称。 也就是说 Compose 构建的镜像则使用 image 中指定的名字webapp:tag命名 command使用 command 可以覆盖容器启动后默认执行的命令 command: bundle exec thin -p 3000 也可以写成类似 Dockerfile 中的格式： command: [bundle, exec, thin, -p, 3000] depends_on解决容器的依赖、启动先后的问题。以下例子中会先启动 redis db 再启动 web 1234567891011version: &apos;3&apos;services: web: build: . depends_on: - db - redis redis: image: redis db: image: postgres 注意：web 服务不会等待redis和db完全启动之后才启动，它是容器启动后就启动，里面的服务有可能还没有起来。 解决办法：一个方面是在连接层面使用自动重连策略，比如mysql jdbc可以有auto reconnect自动重连参数。或者使用下面建议的用一个脚本（wait-for-it.sh）来探测依赖服务已经完全准备好,或者自己编写一个health check脚本来检测依赖服务的健康状况来判断依赖服务是否启动完成。 123456789101112#!/bin/bash# wait-for-postgres.shset -ehost="$1"shiftcmd="$@"until psql -h "$host" -U "postgres" -c '\q'; do &gt;&amp;2 echo "Postgres is unavailable - sleeping" sleep 1done&gt;&amp;2 echo "Postgres is up - executing command"exec $cmd command: [“./wait-for-postgres.sh”, “db”, “python”, “app.py”]注意如果你使用wait-for-it.sh脚本，如果你的基础镜像不包含bash命令（比如alpine镜像）需要安装bash,不然没法执行wait-for-it.sh脚本导致容器启动失败。 如果Dockerfile的基础镜像用的是alpine相关的基础镜像的话，记得添加如下指令安装bash: 123RUN apk updateRUN apk upgradeRUN apk add --no-cache bash environment设置环境变量。你可以使用数组或字典两种格式。 只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。 12345678version: &apos;3.5&apos;services: tomcat_idocv_veiw_rjy: image: XXX environment: - VIRTUAL_HOST=tomcat_idocv_veiw_rjy - VIRTUAL_PORT=8080 - VIRTUAL_NAME=nginx_idocv_veiw_rjy YAML中如果变量名称或者值中用到 true|false，yes|no 等表达布尔 含义的词汇，最好放到引号（单双均可）里，避免 YML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括 y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF expose暴露端口，但不映射到宿主机，只被连接的服务访问。 仅可以指定容器内部的端口为参数 123expose: - &quot;3000&quot; - &quot;8000&quot; ports暴露端口信息 使用宿主端口：容器端口 (HOST:CONTAINER) 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以 12345ports: - &quot;3000&quot; - &quot;8000:8000&quot; - &quot;49100:22&quot; - &quot;127.0.0.1:8001:8001&quot; 注意：当使用 HOST:CONTAINER 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 YAML 会自动解析 xx:yy 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式 expose暴露端口，但不映射到宿主机，只被连接的服务访问。暴露给连接的服务，而不暴露给主机 123expose: - &quot;3000&quot; - &quot;8000&quot; env_file从文件中获取环境变量，可以指定一个文件路径或路径列表，其优先级低于 environment 指定的环境变量如果在配置文件中有build操作，变量并不会进入构建过程中。 1234env_file: .env---------------env_file: - ./common.env links将指定容器连接到当前连接，可以设置别名，避免ip方式导致的容器重启动态改变的无法连接情况 12links: # 指定服务名称:别名 - docker-compose-eureka-server:compose-eureka volumes卷挂载路径设置网络模式 123volumes: - /lib - /var dns配置 dns 服务器，可以是一个值或列表 12345dns: 8.8.8.8------------dns: - 8.8.8.8 - 9.9.9.9 extra_hosts添加主机名的标签，会在/etc/hosts文件中添加一些记录。 123extra_hosts: - &quot;somehost:162.242.195.82&quot; - &quot;otherhost:50.31.209.229&quot; volumes_from从另一个服务或容器挂载其数据卷 123volumes_from: - service_name - container_name entrypoint在Dockerfile中有一个指令叫做ENTRYPOINT指令，用于指定接入点。在docker-compose.yml中可以定义接入点，覆盖Dockerfile中的定义：entrypoint: /code/entrypoint.sh cap_add增加指定容器的内核能力（capacity）。让容器具有所有能力可以指定 12cap_add: - ALL cap_drop去掉指定容器的内核能力（capacity）。去掉NET_ADMIN能力可以指定： 12cap_drop: - NET_ADMIN cgroup_parent创建了一个cgroup组名称为cgroups_1:cgroup_parent: cgroups_1 devices指定设备映射关系，例如： 12devices: - &quot;/dev/ttyUSB1:/dev/ttyUSB0&quot; extends基于其它模板文件进行扩展。例如，对于webapp服务定义了一个基础模板文件为common.yml 123456# common.ymlwebapp: build: ./webapp environment: - DEBUG=false - SEND_EMAILS=false 再编写一个新的development.yml文件，使用common.yml中的webapp服务进行扩展 12345678910111213# development.ymlweb: extends: file: common.yml service: webapp ports: - &quot;8000:8000&quot; links: - db environment: - DEBUG=truedb: image: mysql 后者会自动继承common.yml中的webapp服务及环境变量定义。extends限制如下：A、要避免出现循环依赖B、extends不会继承links和volumes_from中定义的容器和数据卷资源推荐在基础模板中只定义一些可以共享的镜像和环境变量，在扩展模板中具体指定应用变量、链接、数据卷等信息 external_links链接到docker-compose.yml外部的容器，可以是非Compose管理的外部容器。 1234external_links: - redis_1 - project_db_1:mysql - project_db_1:postgresql labels为容器添加Docker元数据（metadata）信息。例如可以为容器添加辅助说明信息 12labels： com.startupteam.description: &quot;webapp for a strtup team&quot; log_driver指定日志驱动类型。目前支持三种日志驱动类型 123log_driver: &quot;json-file&quot;log_driver: &quot;syslog&quot;log_driver: &quot;none&quot; log_opt日志驱动的相关参数 12log_driver: &quot;syslog&quot;log_opt: syslog-address: &quot;tcp://192.168.0.42:123&quot; network_mode设置网络模式 12345network_mode: &quot;bridge&quot;network_mode: &quot;host&quot;network_mode: &quot;none&quot;network_mode: &quot;service:[service name]&quot;network_mode: &quot;container:[container name/id]&quot; net设置网络模式 123net: &quot;bridge&quot;net: &quot;none&quot;net: &quot;host&quot; security_opt指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如，配置标签的用户名和角色名 123security_opt: - label:user:USER - label:role:ROLE 环境变量环境变量可以用来配置Docker-Compose的行为。COMPOSE_PROJECT_NAME设置通过Compose启动的每一个容器前添加的项目名称，默认是当前工作目录的名字。COMPOSE_FILE设置docker-compose.yml模板文件的路径。默认路径是当前工作目录。DOCKER_HOST设置Docker daemon的地址。默认使用unix:///var/run/docker.sock。 DOCKER_TLS_VERIFY如果设置不为空，则与Docker daemon交互通过TLS进行。DOCKER_CERT_PATH配置TLS通信所需要的验证(ca.pem、cert.pem 和 key.pem)文件的路径，默认是 ~/.docker 指令部分整理自以下网友，感谢 https://www.jianshu.com/p/ba77c7bdf03e https://www.jianshu.com/p/7d1fe36ba45c https://blog.51cto.com/9291927/2310444]]></content>
      <categories>
        <category>docker</category>
        <category>docker-compose</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker-compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nfs安装]]></title>
    <url>%2F2019%2F05%2F12%2Fnfs%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[服务端redhat &amp; centos服务端yum install -y nfs-utils rpcbind ubuntu &amp; debian &amp; deepin搜索nfs-开头的软件apt-cache search nfs- 服务端apt install nfs-kernel-server 共享目录12mkdir -p /data/nfs/sharesudo chmod 666 /data/nfs/share NFS配置文件123vim /etc/exports/data/nfs/share 192.168.45.0/24(rw,sync,insecure,no_subtree_check,no_root_squash)/data/nfs/share 192.168.20.0/24(rw,sync,insecure,no_subtree_check,no_root_squash) 格式： 共享目录 客户机ip 共享方式(ro,rw) ro:只读 rw:读写 sync:同步 async:异步（默认） /share (ro, sync) # ‘’表示所有ip/share 192.168.2.250(rw, sync) deepin linux:(rw,sync,no_root_squash,no_subtree_check) 启动 RPC 服务123service rpcbind start或/bin/systemctl start rpcbind.service 查看 NFS 服务项 rpc 服务器注册的端口列表，有些系统需要sudo sudo rpcinfo -p localhost 或 sudo rpcinfo -p localhost | grep nfs 启动 NFS 服务123sudo service nfs-server start或sudo /bin/systemctl start nfs-server.service 再查看一下rpcinfo -p localhost，可以看到有nfs了。 如何知道nfs service名字 12345678910sudo service --status-all | grep nfs结果： [ - ] nfs-common [ + ] nfs-kernel-server 也可以 cd /lib/systemd/system/ ll |grep nfs 结果： nfs-kernel-server.service -&gt; nfs-server.service nfs-server.service 也就是说 nfs-kernel-server也可以，简写就是nfs-server。 检查NFS配置 showmount -e localhost 如果列表为空，说明nfs配置有问题。 showmount表示查看目标地址的共享目录，下面客户端的时候，后面的地址就是服务端IP了。 修改后重新加载配置文件： sudo exportfs -rv 当然修改后，你也可以重启nfs服务 开机自启12345sudo chkconfig rpcbind onsudo chkconfig nfs-server on或sudo systemctl enable rpcbindsudo systemctl enable nfs-server 查看服务是否开机启动,支掉-a只显示activesudo systemctl -la |grep rpcsudo systemctl -la |grep nfs- 客户端一般服务端安装完了，本地就有客户端 123sudo apt install nfs-common或sudo yum install -y nfs-utils 查看目标地址共享目录 showmount -e 192.168.20.110 showmount -e 192.168.45.168 确认自身是否在允许的列表中可使用ifconfig查看自身ip信息，确保自身的ip在允许的列表中 创建挂载点使用mkdir命令创建一个共享目录的挂载点，如果已经有挂载点，可省略此步骤。 本次创建挂载点命令为mkdir -p /data/nfs/client 挂载NFS服务器共享目录到本地sudo mount -t nfs 192.168.20.110:/data/nfs/share /data/nfs/client 如果服务端共享的是/data/nfs/share目录，那么可以直接挂载它下面的子目录，它会自动创建，例如AAA：sudo mount -t nfs 192.168.20.110:/data/nfs/share/AAA /data/nfs/client 为了提高NFS的稳定性，使用TCP协议挂载，NFS默认用UDP协议sudo mount -t nfs 192.168.20.110:/data/nfs/share /data/nfs/client -o proto=tcp -o nolock 卸载 NFS 挂载sudo umount /data/nfs/client 验证查看目录挂载df -h 服务端执行sudo touch /data/nfs/share/testvim /data/nfs/share/test‘Welcome to NFS server’ 注意以下这种没有成功，因为share目录无法进入，权限是666，但是可以通过vi使用。 #sudo echo ‘Welcome to NFS server’ &gt; /data/nfs/share/test 在客户端验证并写入 123vim /data/nfs/client/testWelcome to NFS servercome from client 服务端验证vim /data/nfs/share/test 实现开机自动挂载123vim /etc/fstab 192.168.20.110:/data/nfs/share /data/nfs/client nfs defaults 0 0#192.168.1.3:/nfs_test /mnt/test1 nfs rw,tcp,intr 0 1 固定nfs服务端口NFS启动时会随机启动多个端口并向RPC注册，这样如果使用iptables对NFS端口进行限制就会有点麻烦，可以更改配置文件固定NFS服务相关端口。 123456vim /etc/sysconfig/nfsRQUOTAD_PORT=30001LOCKD_TCPPORT=30002LOCKD_UDPPORT=30002MOUNTD_PORT=30003STATD_PORT=30004 重启service nfs-server restart 查看结果rpcinfo -p localhost]]></content>
      <categories>
        <category>linux</category>
        <category>nfs</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>nfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown示例]]></title>
    <url>%2F2019%2F05%2F11%2Fmarkdown%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[软件推荐工欲善其事，必先利其器。 编写markdown推荐使用vsc（安装markdown preview enhanced更佳）或者Typora软件，当然有道云笔记也不错哦~（当前文章就是从有道云复制共享出来） 目前osc、简书、csdn等都支持markdown。markdown的语法简洁，文档备份方便，是写博客的首选。 目前发现不太方便的就是表格和插图了，图片主要是存储位置在很多软件上面都不统一，尤其是在线编辑器，你把本地的markdown代码很容易复制过去，但是图片就不那么方便，嗯，除非图片都保存在一个统一的云端。 目录示例 [TOC] 目录使用[TOC]就可以生成带有层级的目录了，但是它貌似不是标准的markdown写法，很遗憾hexo和github就不支持。 github生成目录，可以使用vsc的markdown preview enhanced插件 hexo侧边自带文章目录，所以就不折腾了，不信你瞧一眼 标题示例三级标题 \四级标题 \总共6级标题 ，一个#表示1级，注意上面的TOC目录是根据标题等级生成层级关系的 一级标题 ====二级标题 —-这种写法的一二级标题等同于上面的一二级标题，但是很多解析器toc目录会忽略，基本不用 字体效果斜体 ：*斜体*或_斜体_ 加粗 ：**加粗** 加粗 ：***斜体加粗*** 删除线 ：~~删除线~~ 下划线 ：&lt;u&gt;下划线&lt;/u&gt; 高亮字体：==高亮字体== 字体加大变色 1&lt;font color=#A52A2A size=4 &gt;字体加大变色&lt;/font&gt; 列表==列表结尾最好有空行。多个列表连续时中间空2行。== 无序列表（*+-开头后面加空格） 星号开头 加号开头 减号开头 有序列表（数字+英文句号+空格）我数字后没有跟空格，看起来像其实不是有序列表1.有序列表2.有序列表3.有序列表 我是有序列表，在有些编辑器列表会和上面的列表数字连起来。出现这种问题，可以将此行前面加一个空格缩进。 有序列表 有序列表 有序列表 无序嵌套无序，二级前面2个空格1234- 一级 - 二级- 一级 - 二级 效果如下： 一级 二级 一级 二级 有序嵌套无序，二级前面4个空格1234561. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第一个元素 效果如下： 第一项： 第一项嵌套的第一个元素 第一项嵌套的第二个元素 第二项： 第二项嵌套的第一个元素 第二项嵌套的第一个元素 无序++无序+有序实现三级列表1234567+ 一级1 - 二级1.1 - 二级1.2 1. 三级1.2.1 2. 三级1.2.2 - 二级1.3+ 一级2 效果如下： 一级1 二级1.1 二级1.2 三级1.2.1 三级1.2.2 二级1.3 一级2 换行方法1: 连续两个以上空格+回车方法2：使用html语言&lt;br/&gt; 水平线3个连续*或-或_ 注意：超过3个-是二级标题，不过有时候不生效 背景色Markdown本身不支持背景色设置，借助 table, tr, td 等表格标签的 bgcolor 属性来实现背景色的功能(简书，有道云笔记本等不支持)。举例如下： 背景色是：green 注意：html代码块后面要换行，否则在vscode中会有问题。 代码块行内代码块代码块（和引用效果很像）： 一个tab或4个英文空格就是代码块，但是前面要空一行。我是引用。行内代码块，用`括起来：示例：`代码块`结果：代码块 块状代码块块状代码块用以3个`符号开始和结束的，并且开始和结束单独一行 示例&lt;!–￼4–&gt; 效果： 12&lt;xml&gt;我是代码块&lt;/xml&gt;&lt;xml&gt;我是代码块&lt;/xml&gt; 高亮代码块高亮代码块是在开始的3个`后添加具体的语言 &lt;!–￼6–&gt; 效果： 1&lt;xml&gt;高亮代码块&lt;/xml&gt; 引用普通引用引用就是在段落前面添加&gt;示例&gt;引用&gt;引用结果 引用引用 嵌套引用当前层数递增，则层层断开嵌套当前层小于等于上一层，则两层平级 &gt;1层&gt;&gt;2层&gt;&gt;&gt;3层&gt;当前层小于等于上一层，则平级&gt;&gt;2个&gt;&gt;&gt;&gt;3个&gt;当前层大于上一层&gt;&gt;&gt;&gt;4个&gt;&gt;1个&gt;当前层小于等于上一层&gt;&gt;&gt;&gt;&gt;&gt;&gt;7个&gt;断层，因为当前层大于上一层效果: 1层 2层 3层当前层小于等于上一层，则平级2个&gt;3个&gt;当前层大于上一层 4个&gt;1个当前层小于等于上一层 7个&gt;断层，因为当前层大于上一层注意，层的最后一行要空行，不然你会看到这句话也在层里面。同样的问题也出现在列表上。 经验：在使用引用和列表的时候，结尾最好空2行为好。 待办事项- [x] 已完成 - [ ] 未完成 效果： 已完成 未完成 日志研究 路由 Rxjs待办事项后面要换行，否则下面一行的文字会变成待办事项。比如这一行。 hexo不支持todolist，需要安装插件，目前插件和目录有冲突 图片插入1![图片示例](https://note.youdao.com/favicon.ico) 效果 表格| 列1 | 列3 | 列3 | | :— | :–: | —: | | 左对齐 | 居中对齐 | 右对齐 | 列1 列3 列3 左对齐 居中对齐 右对齐 第二行中的字符:在左面左对齐，在两边居中对齐，在右面右对齐，没有:默认左对齐。 表格在线转换tableconvert 右上角导入html，点确定可以直接生成markdown 链接1[有道](https://note.youdao.com/ &quot;鼠标移上来的提示，可以省略&quot;) 效果有道 时序图-&gt; 直线，–&gt;虚线，-&gt;&gt;实线箭头各软件写法目前不统一。建议直接看源码吧。markdown图示例地址 typora和vscode使用js-sequence实现，typora官方说明：显示如下： 简单示例： 复杂示例 以上代码在vscode可以切换主题：`sequence {theme='hand'}` 有道云写法很特殊： 1234567sequenceDiagram客户端-&gt;&gt;用户中心: 获取token，login(uname,pwd)用户中心-&gt;&gt;客户端: 返回token客户端-&gt;&gt;SDK: 调带接口，携带tokenSDK-&gt;&gt;用户中心: 检验token用户中心-&gt;&gt;SDK: 返回token检验结果SDK-&gt;&gt;客户端: token成功或失败返回相应处理结果 Emoji从这里直接点一下就复制了或者使用:表情:，表情二字换成smile 😄:smile: hexonotenote为hexo的插件，普通markdown并不支持格式为： 1&#123;% note class_name %&#125;现在该说点什么呢&#123;% endnote %&#125; class_name有6个值：default，primary，success，info，warning，danger 效果如下 现在该说点什么呢，我没有class_name 现在该说点什么呢 default 现在该说点什么呢 primary 现在该说点什么呢 success 现在该说点什么呢 info 现在该说点什么呢 warning 现在该说点什么呢 danger 文本居中的引用很拽的土豆说：情不知所起、一往而深 Alice->Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob-->Alice: I am good thanks!{"theme":"simple"} var code = document.getElementById("sequence-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value)); var diagram = Diagram.parse(code); diagram.drawSVG("sequence-0", options);Note right of 客户端: 客户端的描述 Note left of 用户中心: 用户中心的描述 Note right of SDK: SDK的描述 客户端->用户中心: 获取token，login(uname,pwd) 用户中心-->>客户端: 返回token 客户端->SDK: 调带接口，携带token SDK->用户中心: 检验token 用户中心-->>SDK: 返回token检验结果 SDK-->>客户端: token成功或失败返回相应处理结果{"theme":"simple"} var code = document.getElementById("sequence-1-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-1-options").value)); var diagram = Diagram.parse(code); diagram.drawSVG("sequence-1", options);]]></content>
      <categories>
        <category>前端</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>PS3</tag>
        <tag>Games</tag>
      </tags>
  </entry>
</search>
